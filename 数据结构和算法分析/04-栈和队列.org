#+title:数据结构与算法分析读书笔记系列04-栈和队列
#+date:20180628
#+email:anbgsl1110@gmail.com
#+keywords: 数据结构 算法分析 表、栈和队列  jiayonghliang
#+description:表、栈和队列
#+options: toc:2 html-postamble:nil
#+html_head: <link rel="stylesheet" href="http://www.jiayongliang.cn/css/org.css" type="text/css" /><div id="main-menu-index"></div><script src="http://www.jiayongliang.cn/js/add-main-menu.js" type="text/javascript"></script>
* 前言
每一个有意义的程序都将明晰地至少使用一种这样的数据结构，而栈则在程序中总是要间接地用到，不管你在程序中是否做了申明。
* 栈ADT
** 栈模型
栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈的顶（top）。对栈的基本操作有Push（进栈）和Pop（出栈），前者相当于插入，后者则是删除最后插入的元素。

[[/static/img/数据结构和算法分析/img_6.png]]

栈有时又叫做LIFO（后进先出表）。上图中描述的模型只象征着Push是输入操作而Pop和Top是输出操作。普通的清空栈的操作和判断空栈的测试都是栈的操作指令系统中的一部分，但对栈能做的，基本上也就是Push和Pop操作。

下图表示在进行若干操作后的一个抽象的栈。

[[/static/img/数据结构和算法分析/img_7.png]]

** 栈的实现
由于栈是一个表，因此任何实现表的方法都能实现栈。两个流行的实现方法，一种方法使用指针，而另一种方法则使用数组。
*** 栈的链表实现
栈的第一种实现方法是使用单链表。我们通过在表顶端插入来实现Push，通过删除表顶端元素来实现Pop。Top操作只是考查表顶端元素并返回它的值。有时Pop操作和Top操作合二为一。

很清楚，所有的操作均花费常数时间，因为没有任何地方涉及到栈的大小（空栈除外），更不用说依赖于栈大小的循环了。这种实现方法的缺点在于对malloc和free的调用的开销是昂贵的。有时候可以通过使用第二个栈避免。

*** 栈的数组实现
另一种实现方法避免了指针并且可能是更流行的解决方案。这种策略的唯一潜在危害是我们需要提前声明一个数组的大小。一般来说，这并不是问题，因为在典型的应用程序中，即使有很多的栈操作，在任一时刻栈元素的实际个数不会太大。不过不能做到这一点，那么节省的做法是使用链表来实现。

用一个数组实现栈是很简单的。每一个栈有一个TopOfStack，对于空栈它是-1（这就是空栈的初始化）。为了将某个元素X压入到该栈中，我们将TopOfStack加1，然后置Stack[TopOfStack] = X，其中Stack是代表具体栈的数组。为了弹出栈元素，我们置返回值为Stack[TopOfStack]然后TopOfStack减1。

注意，这些操作不仅以常数时间运行，而且是以非常快的常数时间运行。在某些机器上。若在带有自增和自减寻址功能的寄存器上操作，则（整数的）Push和Pop都可以写成一条机器指令。

** 应用
*** 平衡符号
编译器检查你的程序语法错误，但是常常由于缺少一个符号（如遗漏一个花括号或是注释起始符）引起编译器列出上百行的诊断，而真正的错误并没有找出。

这种情况下一个有用的工具就是检验是否每件事情都能成对出现的一个程序。
*** 后缀表达式
#+BEGIN_SRC C
  1.1 3.2 + 9.9 + 6.99 * +
#+END_SRC
上面的这个记法叫做后缀（postfix）或逆波兰（reverse Polish）记法，计算这个问题最容易的方法是使用一个栈。
*** 中缀到后缀的转换
栈不仅可以用来计算后缀表达式的值，而且还可以用栈将一个标准形式的表达式（或叫做中缀式（infix））转换成后缀式。
*** 函数调用
该问题类似于平衡符号的原因在于，函数调用和函数返回基本类似于开括号和闭括号，二者想法是一样的。
* 队列ADT
像栈一样，队列（queue）也是表。然而，使用队列时插入在一端进行而删除则在另一端进行。
** 队列模型
队列的基本操作是Enqueue(入队)，它是在表的末端（叫做队尾（rear））插入一个元素，还有Dequeue（出队），它是删除（或返回）在表的开头（叫做队头（front））的元素。

[[/static/img/数据结构和算法分析/img_8.png]]

** 队列的数组实现
如同栈的情形一样，对于队列而言任何表的实现都是合法的。像栈一样，对于每一种操作，链表实现和数组实现都给出快速的O（1）运行时间。

对于每一个队列数据结构，我们保留一个数组Queue[]以及位置Front和Rear，它们代表队列的两端。我们还要记录实际存在于队列中的元素的个数Size。所有这些信息是作为一个结构的一部分，除队列例程本身外通常不会有例程直接访问它们。下图表示处于某个中间状态的一个队列。顺便指出，图中哪些空白单元是有着不确定的值的。特别地，前两个单元含有曾经属于该队列的元素。

[[/static/img/数据结构和算法分析/img_9.png]]

操作是清楚的，为使一个元素X入队，我们让Size和Rear增1，然后值Queue[Rear] = X。若使一个元素出队，我们置返回值为Queue[Front]，Size减1，然后使Front增1。

对于上述实现一个潜在问题是，队列满了，下一次入队就会是一个不存在的位置。简单的解决方法是，只要Front或Rear到达数组的尾端，它就又绕回开头。这种叫循环数组（circular array）实现。

实现回绕所需要的附加代码是极小的（它可能使得运行时间加倍）。如果Front或Rear增1使得超越了数组，那么其值就要重置为数组的第一个位置。

关于队列的循环实现，有两件事要警惕。
1. 检测队列是否为空是很重要的，因为当队列为空时一次Dequeue操作将不知不觉地返回一个不确定的值。
2. 某些程序设计人员使用不同的方法来表示队列的队头和队尾。

** 队列的应用
1. 打印任务
2. 买票排队
3. 计算机网络
4. 排队论的问题
正如栈一样，队列还有其他丰富的用途。