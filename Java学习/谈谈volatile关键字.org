#+title:谈谈volatile关键字
#+date:2021-12-26
#+email:anbgsl1110@gmail.com
#+keywords: Java volatile 并发编程  jiayonghliang
#+description:java volatile关键字
#+options: toc:3 html-postamble:nil
#+html_head: <link rel="stylesheet" href="http://www.jiayongliang.cn/css/org3.css" type="text/css" /><div id="main-menu-index"></div><script src="http://www.jiayongliang.cn/js/add-main-menu.js" type="text/javascript"></script>
* 前言
关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易被正确地、完整地理解，以至于很多人都习惯不去使用它，遇到需要处理多线程数据竞争的问题时一律使用synchronized来进行同步。

Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。
* 并发编程的3个基本概念
** 原子性
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
** 可见性
指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
** 有序性
即程序执行的顺序按照代码的先后顺序执行。
* volatile变量的特性
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2. 禁止进行指令重排序。
** 保证可见性，不保证原子性
当变量加了 volatile 后，它会保证完全可见性：
1. 如果线程 A 写入一个 volatile 变量，之后线程 B 读取该变量，则线程 A 写入该变量之前线程就可见（定义的、修改的）的所有变量都将对线程 B 可见。JVM 会强制将缓存中的这些变量写入内存中。
2. 如果线程 A 读取一个 volatile 变量，则读取该变量之前线程 A 可见的所有变量都会从内存中重新读取。

深入来说，通过加入内存屏障和禁止重排序优化来实现的：

对volatile变量执行写操作时，会在写操作后加入一条store屏障指令，强制刷新到主内存；

对volatile变量执行读操作时，会在读操作前加入一条load指令，强制从主内存读取。

但是，volatile不能保证原子性。
** 禁止指令重排
内存可见性只是 volatile 的其中一个语义，它还可以防止 JVM 进行指令重排优化。

重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：

a.重排序操作不会对存在数据依赖关系的操作进行重排序。

b.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变

重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果。

代码的执行顺序与实际书写顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化，主要有3种：

（1）编译器优化的重排序；（编译器优化）

（2）指令集并行重排序（处理器优化）；

（3） 内存系统的重排序（处理器优化）。

加上 volatile 之后可以防止这样的重排优化，保证业务的正确性。

* 使用volatile关键字的场景
要在多线程中安全的使用volatile变量，必须同时满足：

（1） 对变量的操作不依赖其当前值

（2） 该变量没有包含在具有其他变量的不变式中

volatile不需要加锁，不会阻塞线程，效率高于synchronized，但只能保证内存可见性，无法保证原子性。


参考资料：《深入理解Java虚拟机》
